## 1장에서 다루는 주요 내용
- 단일 서버에서 시작하여 시스템의 규모를 확장하는 방법
- RDBMS vs NoSQL
- scale-up vs scale-out
- 로드밸런서
- 데이터베이스 다중화
- 캐시, CDN
- stateful vs stateless
- 메시지 큐
- 데이터베이스의 규모 확장
- 정리

## 단일 서버
단일 서버 시스템은 application, database, cache등이 전부 서버 한 대에서 실행된다.
## 데이터베이스
사용자가 늘어나면 서버 하나로는 충분하지 않아서 여러 서버를 두어야 한다. 그 중 가장 첫 번째로 분리해야 할 서버는 데이터베이스 서버이다. 
#### 어떤 데이터베이스를 사용할 것인가?
- 관계형 데이터베이스
	- RDBMS(Relational Database Management System)이라고도 부르며 테이블, 열, 칼럼으로 자료를 표현한다.
	- 대표적으로 Oracle, MySQL, MariaDB, MSSQL, PostgreSQL 등이 있다.
	- SQL을 사용하여 여러 테이블에 있는 데이터를 join하여 조회할 수 있다.
- 비 관계형 데이터베이스
	- NoSQL이라고도 부른다.
	- 대표적으로 MongoDB, Redis, Amazon DynamoDB 등이 있다.
	- NoSQL은 네 부류로 나뉜다.
		- Key-Value store (Redis)
		- graph store(Neo4j)
		- column store (HBase)
		- document store (MongoDB)
	- 일반적으로 조인 연산은 지원하지 않는다.
	- 아래와 같은 경우에는 NoSQL이 바람직한 선택일 수 있다.
		- 아주 낮은 응답 지연시간(latency)이 요구됨.
		- 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님
		- 데이터(JSON, YAML, XML 등)를 직렬화하거나(serialize) 역직렬화(deserialize)할 수 있기만 하면 됨. 즉, 데이터를 받은 대로 저장하고 저장한 대로 데이터를 읽을 수만 있으면 되는 경우.
		- 아주 많은 양의 데이터를 저장할 필요가 있는 경우. NoSQL은 RDBMS보다 수평적 확장이 쉽기 때문에 더 많은 서버를 추가하여 저장 공간과 처리 능력을 향상 시킬 수 있다.
## 수직적 규모 확장 vs 수평적 규모 확장
시스템을 확장은 크게 두 부류로 나뉠 수 있다.
- scale-up
	- 수직적 규모 확장으로 서버에 고사양 자원(CPU, Memory 등)을 추가하는 행위를 말한다.
	- 단순하게 확장할 수 있기 때문에 서버에 유입되는 트래픽의 양이 적은 상황에 사용하기 좋은 확장법이다.
	- 한 대의 서버에 자원을 무한대로 증설할 방법이 없기 때문에 한계과 명확하다.
	- 장애에 대한 자동 복구(failover) 방안이 없기 때문에 서버에 장애가 발생하면 서버에서 실행되고 있는 전체 프로세스에 장애가 발생할 수 있다.
- scale-out
	- 수평적 규모 확장으로 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.
	- 위에서 언급한 scale-up에 대한 단점 때문에 대규모 애플리케이션 시스템에서는 scale-out이 더 적절하다.
## 로드밸런서
부하 분산 집합(load balancing set)에 속한 애플리케이션 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다. 

애플리케이션 서버가 다운되거나 너무 많은 사용자로 인해 서버의 자원의 사용율이 한계치까지 도달하여 응답 속도가 느려지거나 최악의 상황에서는 서버가 다운되어 접속이 불가능하게 된다. 이런 문제를 해결하기 위해 대규모 애플리케이션 시스템에서는 서버를 scale-out과 로드밸런서를 사용하여 애플리케이션 서버에 트래픽을 고르게 분산 시키는 방법을 많이 사용하고 있다. 

애플리케이션 앞단에 로드밸런서가 존재하게 되면 서버의 IP를 client에게 공개하지 않아도 되며, 로드밸런서와 서버간 통신은 사설 IP를 사용할 수 있기 때문에 보안적인 이점도 얻을 수 있다. 또한 scale-out으로 추가된 서버 덕분에 failover가 가능한 구조가 된다.

따라서 로드밸런스는 리버스 프록시 역할을 수행하면서 시스템의 확장성, 가용성, 보안성을 높여준다.

온프레미스 환경에서는 Nginx 같은 웹서버를 사용해 로드밸런서를 구축할 수 있으며, 클라우드 서비스를 사용한다면 서비스 내에 로드밸런서를 쉽게 구축할 수 있는 기능이 있다.
## 데이터베이스 다중화
많은 데이터베이스 관리 시스템이 다중화를 지원하며 보통은 master-slave 관계를 설정하고 write operation은 master DB에서 이루어지며 read operation은 slave DB에서 이루어진다.

대부분 애플리케이션은 write operation의 비중 보다 read operation의 비중이 높기 때문에 master DB 보다 slave DB의 수가 더 많으며, 데이터베이스를 다중화 하면 다음과 같은 이점이 있다.
- 모든 write operation은 master DB 서버에서 이루어지는 반면 read operation은 slave DB에서 이루어 지기 때문에 병렬로 처리될 수 있는 query의 수가 늘어나므로 성능이 좋아진다.
- 자연 재해 및 서버의 장애가 발생하더라도 다른 지역에 있는 서버 또는 같은 지역의 다른 서버에 데이터를 가져와 계속 서비스를 할 수 있기 때문에 안전성과 가용성이 높아진다.

한 가지 예로 MySQL Replication을 살펴보겠다. 
1. master DB에 write operation의 commit이 일어나면 binary log에 기록이된다. 
2. slave DB의 I/O 스레드가 master DB의 binary log를 주기적으로 읽어 relay log에 기록한다.
3. slave DB의 SQL 스레드가 relay log를 읽어 write operation을 실행하여 데이터를 동기화 한다.
이 방식은 실제 데이터를 전송하는 것이 아니기 때문에 복제 데이터 전송량을 줄일 수 있다는 장점이 있다.

이 방식의 단점으로는 복제 지연이 존재하기 때문에 master DB가 다운되어 다른 slave DB가 master의 역할을 하게 되는 경우 데이터가 최신 상태임을 보장할 수 없기 때문에 이러한 상황을 대비하여 설계 구성이 복잡한 multi-master, circular replication 방식의 도입을 고려해봐야 한다.
## 캐시
캐시는 비용이 많이드는 연산 또는 자주 바뀌지 않으면서 자주 참조되는 데이터를 메모리 안에 저장하는 기법이다. 캐시를 사용하면 응답 시간(latency)을 개선할 수 있다.

애플리케이션의 성능은 데이터베이스 호출 횟수에 많은 영향을 받는다. 예를 들자면 애플리케이션은 DB Connection Pool을 사용하는데 이 자원은 유한한 자원이며 CPU Core 수와 직접적인 연관이있다. 그렇기 때문에 Connection Pool의 크기를 무작정 늘린다고 해서 모두다 사용할 수 있는 것이 아니다.

캐시 계층에 데이터를 보관하게 되면 애플리케이션의 성능만 증가할 뿐만 아니라 데이터베이스 서버의 부하를 줄일 수 있다. 캐시 전략은 캐시할 데이터의 종류, 크기, 액세스 패턴에 맞는 전략을 선택해야 사용하면 된다.

캐시 사용시 주의할 점은 다음과 같다.
- 데이터의 갱신이 자주 일어나지 않지만 참조는 빈번하게 일어난다면 캐시 도입을 고려해볼 만하다.
- 캐시는 접근 속도는 빠르지만 데이터가 휘발될 수 있는 메모리에 저장이 되기 때문에 영속적으로 보관해야되는 데이터를 캐시에 두는 것은 바람직하지 않다.
- 캐시에 보관된 데이터의 만료 시간에 대한 정책을 잘 정해야한다. 만료 기한이 너무 길면 원본 데이터와 차이가 날 가능성이 높아지고 너무 짧으면 데이터베이스를 너무 자주 호출하기 때문에 만료 시간을 적절하게 설정하는 것이 중요하다.
- 데이터베이스와 캐시 내의 데이터가 같은지에 대한 일관성을 지키는 것은 매우 어려운 작업이기 때문에 어떻게 일관성을 지킬 것인지 고민해봐야 한다.
- 캐시 서버를 한 대만 두는 것은 단일 장애 지점(Single Point of Failure, SPOF)이 되어버릴 가능성이 있기 때문에 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
- 캐시 메모리가 꽉 찬 경우 방출 정책을 무엇을 사용할 건지 정해야한다. LRU, LFU, FIFO등 다양한 정책이 있다.
- 캐시 메모리를 너무 작게 설정했을 때 엑세스 패턴에 따라 캐시에 있는 데이터가 자주 밀려나는 현상(eviction)이 나타나 성능이 떨어질 수 있다. 이 문제를 해결하기 위해 캐시 메모리를 과할당(overprovision)하기도 한다.
## 콘텐츠 전송 네트워(CDN)
CDN은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. 이미지, 비디오, CSS, Javascript 파일 등을 캐시할 수 있다.

CDN 사용 시 고려해야할 사항은 다음과 같다.
- CDN은 보통 third-party providers에 의해 운영되며, CDN으로 들어오고 나가는 데이터 전송 양에 따라 요금을 내게 된다. 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 성능적, 비용적으로 이득이 크지 않으므로 CDN에서 빼야한다.
- 캐시와 마찬가지로 콘텐츠에 대해서 적절한 만료 시간을 설정해야 한다.
- CDN 자체가 죽었을 경우 해당 문제를 감지하여 원본 서버로부터 직접 콘텐츠를 가져오도록 구성하는 것이 필요하다.
- 아직 만료되지 않은 콘텐츠라도 오브젝트 버저닝(object versioning)을 사용해 콘텐츠를 무효화할 수 있어야한다.
## 무상태(stateless) 계층
애플리케이션을 scale-out 하기 위해서 세션과 같은 상태 정보를 애플리케이션에서 제거를 해야한다. 

#### stateful architecture
한 가지 예로 로드밸런서가 클라이언트의 요청을 1번, 2번 서버로 고르게 보내고 있다고 가정하겠다. 이때 1번 서버의 상태를 2번 서버는 모르기 때문에 로드밸런서의 sticky session이라는 기능을 사용해 1번 서버로 요청이 간 경우에는 다음 요청도 1번 서버로 요청을 보내줘야한다. 이러한 구성에서는 트래픽이 몰렸을 때 유연하게 scale-out을 하기 까다로워진다.
#### stateless architecture
stateful architecture의 문제점을 stateless architecture를 사용해서 해결할 수 있다.
상태 정보는 외부 저장소인 데이터베이스 서버(RDB, NoSQL)에 저장하여 필요할 때 외부 저장소에서 가져오도록 구성하는 것이다. 이러한 구조는 단순하고 안정적이며 확장이 쉽다.

대표적인 예로 JWT를 사용한 access token과 짧은 만료 시간을 가진 acess token의 단점을 보완하기 위해 사용 되는 refresh token을 들 수 있다.
1. 애플리케이션 서버는 인증된 유저의 식별 정보를 acess token에 담아 반환하고 refresh token은 외부 저장소에 저장한다.
2. 클라이언트는 access token을 저장하고 애플리케이션에 요청을 보낼 때 마다 access token을 헤더에 추가한다.
3. 애플리케이션은 헤더에 추가된 access token을 검증한다. access token의 유효 시간이 만료된 경우 외부 저장소의 refresh token의 만료 시간을 보고 로그아웃을 시키거나 access token을 재발급 해준다.
위 예시는 많이 사용되는 방식이며 stateful architecture와 다르게 트래픽이 몰렸을 때 애플리케이션의 서버를 유연하게 scale-out을 할 수 있다.
## 데이터 센터
가용성을 높이기 위해서는 데이터 센터를 지원하는 것이 필수다. 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데, 통상 이 절차를 지리적 라우팅(GeoDNS-routing, Geo-routing)이라고 부른다. 다중 데이터센터 아키텍처를 만드려면 몇 가지 기술적 난제를 해결해야한다.
- GeoDNS를 통해 사용자에게 가장 가까운 데이터 센터(올바른 데이터 센터)로 트래픽을 보내는 효과적인 방법을 찾아야 한다.
- 여러 지역에 존재하는 데이터베이스의 데이터를 동기화 시켜야 한다.
- 여러 지역에 존재하는 애플리케이션을 테스트 해보는 것이 중요하다. 또한 CICD를 통해 모든 데이터 센터의 동일한 서비스가 설치되도록 해야한다. (애플리케이션의 버전을 말하는 듯)
## 메시지 큐
메시지 큐는 메시지의 무손실 즉, 메시지 큐의 일단 보관된 메시지는 소비자가 꺼낼 때 까지 안전히 보관된다는 특성(durability)을 보장하는 비동기 통신을 지원하는 기술이다. 메시지 큐의 기본 아키텍처는 producer라고 불리는 서비스에서 메시지를 만들어 메시지 큐에 publish 한다. 메시지 큐에는 consumer라고 불리는 서비스가 연될되는데, 이는 메시지를 받아 그에 맞는 동작을 수행한다. 

메시지 큐를 사용했을 때의 장점은 다음과 같다.
- 서비스 또는 서버 간 결합이 느슨해져서 producer와 cousumer를 독립적으로 확장할 수 있다.
	- producer에서 발행하는 메시지가 양에 따라 consumer를 늘리거나 줄일 수 있다.
- 결합이 느슨해지기 때문에 서로의 장애의 영향을 받지 않는다.
- 선착순 이벤트 같이 처리 순서가 중요하고 요청이 많아질 수 있는 경우 consumer를 통해 처리량을 조절하고 순차적으로 처리할 수 있다.
## 로그, 메트릭 그리고 자동화
애플리케이션의 규모가 커질 수록 로그와 메트릭은 필수다.
토이 프로젝트나 실무에서 애플리케이션을 운영하다 예외가 발생했던 경험을 한 적이 있을 거다. 이때 로그를 남기지 않은 경우에는 디버깅이 상당히 어려워지기 때문에 로그를 남기는 건 규모가 작던 크던 필수라고 생각한다. 로그를 보는 방법은 서버에서 로그 파일을 직접 보는 방법도 존재하지만 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다. 대표적인 도구로 ELK가 있다.

또한 애플리케이션의 서버의 CPU, Memory, Disk I/O, JVM을 위에서 동작하는 애플리케이션이라면 Heap 등 메트릭 정보를 볼 수 있는 APM을 도입하면 서버의 자원을 편리하게 관찰할 수 있다.
## 데이터베이스의 규모 확장
저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다. 이러한 상황에서 데이터베이스의 규모를 확장하는 두 가지 방법이 존재한다.
#### 수직적 확장
앞에서 봤던 scale-up과 동일하다 데이터베이스 서버에 고사양 자원을 추가(증설)하는 방법이다. 하지만 이 방식에는 단점이 존재한다.
- 서버의 scale-up가 동일하게 서버의 자원은 무한대로 증설할 수 없다.
- 단일 장애 지점(SPOF)로 인한 위험성이 크다.
- 고성능 서버로 갈수록 서버의 유지 비용이 많이 발생한다.
#### 수평적 확장
데이터베이스의 수평적 확장은 shading이라고 부른다. 대규모 데이터베이스를 shard라는 작은 단위로 분할하여 더 많은 서버를 추가함으로써 성능을 향상 시키는 방법이다. 모든 shard는 같은 스키마를 사용하지만 shard에 보관되는 데이터에는 중복이 없어야 한다. 

데이터베이스에 sharding을 도입할 때 가장 중요한 것은 적절한 sharding key(또는 partition key)를 정하는 것이다. sharding key를 정할 때는 데이터를 고르게 분할해서 저장될 수 있도록 하는 것이 가장 중요하다. sharding key는 하나 이상의 컬럼으로 구성되며 이 key를 사용해 shard된 데이터베이스에 query 요청을 보내게 된다. 

데이터베이스에 sharding을 도입할 때 고민해야할 부분은 다음과 같습니다.
- 데이터가 많아져 shard가 부족해지거나 shard간 데이터 분포가 균등하지 못 해 특정 shard의 할당된 자원이 다른 shard에 비해 빨리 진행되는 현상인 shard exhaustion(샤드 소진)이 나타나는 경우 shard key를 계산하는 함수를 변경하고 데이터를 재배치 해여한다. 이 문제는 consistent hashing(안정 해시) 기법을 활용하여 해결할 수 있다.
- 유명인사가 존재하는 shard에는 read operation 때문에 과부하가 걸리게 된다. 이 문제는 유명인사 각각에 shard를 하나씩 할당하거나 shard를 더 잘게 쪼개는 방법으로 해결할 수 있다.
- 여러 shard에 걸친 데이터를 조인하기 힘들어진다. 이 문제는 비정규화 테이블을 만들거나 NoSQL을 도입하여 해결할 수 있다.
## 정리
이번 장에서는 사용자 수에 따라 시스템의 규모를 점진적으로 확장시키는 방법에 대해서 설명했다. 내용을 요약하자면 다음과 같다.
- 웹 계층은 무상태여야 한다.
- 성능 개선과 고가용성을 위해 모든 계층에 다중화를 도입해야 한다.
- 애플리케이션에서는 갱신이 자주 일어나지 않고 자주 참조되는 데이터를 캐싱하고 정적 콘텐츠를 캐싱하는 CDN을 통해 응답 시간을 개선해야 한다.
- 데이터베이스의 샤딩을 도입해야 한다.
- 각 계층을 독립적인 서비스로 분할해야 한다. 애플리케이션, 캐시, 데이터베이스가 하나의 서버에 존재하면 SPOF가 되기 쉽상이다.
- 시스템을 지속적으로 모니터링하고 테스트와 배포를 자동화 할 수 있는 도구를 도입해야 한다.
